/**
 * @arch archcodex.cli.data
 * @intent:documentation-examples
 *
 * Hook script templates for `archcodex init-hooks`.
 * Each template uses {{CMD}} as a placeholder for the archcodex command.
 */

export const SESSION_START_HOOK = `#!/bin/bash
# ArchCodex session start hook: Prime context with architectural constraints
# Generated by: archcodex init-hooks

cd "$CLAUDE_PROJECT_DIR" 2>/dev/null || exit 0

CONTEXT=$({{CMD}} session-context 2>/dev/null)

if [ -n "$CONTEXT" ]; then
  cat <<CTXEOF
ARCHCODEX SESSION CONTEXT (auto-loaded at session start):
Run 'archcodex session-context --with-patterns' for canonical implementations.

$CONTEXT
CTXEOF
fi

exit 0
`;

export const PRE_READ_HOOK = `#!/bin/bash
# ArchCodex pre-read hook: Auto-inject architectural constraints for src/ files
# Generated by: archcodex init-hooks

INPUT=$(cat)
FILE_PATH=$(echo "$INPUT" | jq -r '.tool_input.file_path // empty')

# Skip if no file path
if [ -z "$FILE_PATH" ]; then
  exit 0
fi

# Skip non-project directories
if [[ "$FILE_PATH" =~ (node_modules|\\.git|dist|build|coverage)/ ]]; then
  exit 0
fi

# Only src/ TypeScript/JavaScript files
if [[ ! "$FILE_PATH" =~ (^|/)src/ ]]; then
  exit 0
fi
if [[ ! "$FILE_PATH" =~ \\.(ts|tsx|js|jsx)$ ]]; then
  exit 0
fi

# Auto-inject architectural constraints
cd "$CLAUDE_PROJECT_DIR" 2>/dev/null || exit 0
ARCH_CONTEXT=$({{CMD}} read "$FILE_PATH" --format ai 2>/dev/null)
if [ -n "$ARCH_CONTEXT" ]; then
  jq -n --arg ctx "ARCHITECTURAL CONSTRAINTS for this file:
$ARCH_CONTEXT" '{
    "hookSpecificOutput": {
      "hookEventName": "PreToolUse",
      "additionalContext": $ctx
    }
  }'
fi

exit 0
`;

export const PRE_WRITE_HOOK = `#!/bin/bash
# ArchCodex pre-write hook: Remind about archcodex discover for new files
# Generated by: archcodex init-hooks

INPUT=$(cat)
FILE_PATH=$(echo "$INPUT" | jq -r '.tool_input.file_path // empty')

# Skip if no file path
if [ -z "$FILE_PATH" ]; then
  exit 0
fi

# Only TypeScript/JavaScript files
if [[ ! "$FILE_PATH" =~ \\.(ts|tsx|js|jsx)$ ]]; then
  exit 0
fi

if [[ ! "$FILE_PATH" =~ (^|/)src/ ]]; then
  exit 0
fi

# Check if file already exists
if [ -f "$FILE_PATH" ]; then
  exit 0
fi

# New file being created - check if it has @arch tag
CONTENT=$(echo "$INPUT" | jq -r '.tool_input.content // empty')

if echo "$CONTENT" | grep -q "@arch"; then
  exit 0
fi

# Missing @arch tag - provide feedback (don't block, just warn)
cat <<WARNEOF
{
  "hookSpecificOutput": {
    "hookEventName": "PreToolUse",
    "additionalContext": "NEW FILE: $FILE_PATH - Ensure it has @arch tag. Run '{{CMD}} discover \\"<description>\\"' to find the right architecture."
  }
}
WARNEOF

exit 0
`;

export const REMINDER_HOOK = `#!/bin/bash
# ArchCodex reminder hook: Adds workflow reminder on every Write/Edit to src/ files
# Generated by: archcodex init-hooks

INPUT=$(cat)
FILE_PATH=$(echo "$INPUT" | jq -r '.tool_input.file_path // empty')

# Skip if no file path
if [ -z "$FILE_PATH" ]; then
  exit 0
fi

# Skip non-project directories
if [[ "$FILE_PATH" =~ (node_modules|\\.git|dist|build|coverage)/ ]]; then
  exit 0
fi

# Only remind for src/ source files
if [[ ! "$FILE_PATH" =~ (^|/)src/ ]]; then
  exit 0
fi

# Only TypeScript/JavaScript files
if [[ ! "$FILE_PATH" =~ \\.(ts|tsx|js|jsx)$ ]]; then
  exit 0
fi

# Output reminder for Claude's context
cat <<'REMEOF'
ARCHCODEX WORKFLOW REMINDER:
1. BEFORE creating files: \`archcodex discover "<description>"\` to find the right architecture
2. BEFORE editing files: constraints are auto-injected via the pre-read hook
3. BEFORE adding imports: \`archcodex neighborhood <file>\` to check import boundaries
4. AFTER changes: \`archcodex check <file>\` to validate (the post-write hook does this automatically)
REMEOF
`;

export const PLAN_MODE_HOOK = `#!/bin/bash
# ArchCodex plan mode hook: Remind to use plan-context for scoped constraints
# Generated by: archcodex init-hooks

cat <<'PLANEOF'
ARCHCODEX PLAN MODE REMINDER:
When planning multi-file changes, run scoped context first:

1. \`archcodex plan-context <directory>\` - Get constraints for the target area
2. \`archcodex validate-plan --stdin\` - Validate proposed changes BEFORE writing
3. \`archcodex check "<glob>"\` - Validate after implementation

Example:
  archcodex plan-context src/core/health/
  echo '{"changes":[{"path":"src/core/health/scorer.ts","action":"create","archId":"archcodex.core.engine"}]}' | archcodex validate-plan --stdin
PLANEOF

exit 0
`;

export const POST_WRITE_HOOK = `#!/bin/bash
# ArchCodex post-write hook: Run archcodex check after Write/Edit
# Generated by: archcodex init-hooks

# Read input from stdin
INPUT=$(cat)

# Extract file path from JSON input
FILE_PATH=$(echo "$INPUT" | jq -r '.tool_input.file_path // empty')

# Skip if no file path
if [ -z "$FILE_PATH" ]; then
  exit 0
fi

# Only check src/ files
if [[ ! "$FILE_PATH" =~ (^|/)src/ ]]; then
  exit 0
fi

# Skip non-source files
if [[ ! "$FILE_PATH" =~ \\.(ts|tsx|js|jsx)$ ]]; then
  exit 0
fi

# Run archcodex check
cd "$CLAUDE_PROJECT_DIR" 2>/dev/null || exit 0
RESULT=$({{CMD}} check "$FILE_PATH" --json 2>&1)

# Parse result
ERRORS=$(echo "$RESULT" | jq -r '.summary.totalErrors // 0')
WARNINGS=$(echo "$RESULT" | jq -r '.summary.totalWarnings // 0')

# If errors, block with structured feedback
if [ "$ERRORS" -gt 0 ]; then
  VIOLATIONS=$(echo "$RESULT" | jq -r '.results[0].violations[] | "- \\(.rule): \\(.message)\\n  Fix: \\(.fix_hint)"' 2>/dev/null)

  cat <<BLOCKEOF
{
  "decision": "block",
  "reason": "ArchCodex found $ERRORS error(s). Fix before continuing:\\n$VIOLATIONS",
  "hookSpecificOutput": {
    "hookEventName": "PostToolUse",
    "additionalContext": "File $FILE_PATH has architectural violations. Run '{{CMD}} check $FILE_PATH --json' for details."
  }
}
BLOCKEOF
  exit 0
fi

# If warnings, just inform (don't block)
if [ "$WARNINGS" -gt 0 ]; then
  echo "ArchCodex: $WARNINGS warning(s) in $FILE_PATH (non-blocking)"
fi
`;

/**
 * The hooks section for .claude/settings.json.
 */
export const HOOKS_SETTINGS = {
  SessionStart: [
    {
      hooks: [
        {
          type: 'command',
          command: '.claude/hooks/archcodex-session-start.sh',
        },
      ],
    },
  ],
  PreToolUse: [
    {
      matcher: 'Write',
      hooks: [
        {
          type: 'command',
          command: '.claude/hooks/archcodex-pre-write.sh',
        },
      ],
    },
    {
      matcher: 'Write|Edit',
      hooks: [
        {
          type: 'command',
          command: '.claude/hooks/archcodex-reminder.sh',
        },
      ],
    },
    {
      matcher: 'Read',
      hooks: [
        {
          type: 'command',
          command: '.claude/hooks/archcodex-pre-read.sh',
        },
      ],
    },
    {
      matcher: 'EnterPlanMode',
      hooks: [
        {
          type: 'command',
          command: '.claude/hooks/archcodex-plan-mode.sh',
        },
      ],
    },
  ],
  PostToolUse: [
    {
      matcher: 'Write|Edit',
      hooks: [
        {
          type: 'command',
          command: '.claude/hooks/post-write-archcodex.sh',
        },
      ],
    },
  ],
};

/**
 * Map of hook filenames to their template constants.
 */
export const HOOK_FILES: Record<string, string> = {
  'archcodex-session-start.sh': SESSION_START_HOOK,
  'archcodex-pre-read.sh': PRE_READ_HOOK,
  'archcodex-pre-write.sh': PRE_WRITE_HOOK,
  'archcodex-reminder.sh': REMINDER_HOOK,
  'archcodex-plan-mode.sh': PLAN_MODE_HOOK,
  'post-write-archcodex.sh': POST_WRITE_HOOK,
};
