/**
 * @arch archcodex.core.context.extractor
 * @intent:stateless
 *
 * Convex schema extractor - uses Convex's introspection API for accurate extraction.
 * Executes a script in the user's project to access schema.tables[name].validator.
 */

import * as path from 'node:path';
import { execSync } from 'node:child_process';
import { writeFile as fsWriteFile, unlink, readFile } from 'node:fs/promises';
import { fileExists } from '../../../utils/file-system.js';
import type { RelationshipType } from '../types.js';
import type {
  ISchemaExtractor,
  ExtractionOptions,
  SchemaExtractionResult,
  ExtractedEntity,
} from './types.js';

/**
 * Paths where Convex schema might be located.
 */
const CONVEX_SCHEMA_PATHS = [
  'convex/schema.ts',
  'convex/schema.js',
];

/**
 * Generate the extraction script with the output path injected.
 * Uses Convex's introspection API for accurate schema extraction.
 * Writes output to file instead of stdout to avoid Node.js buffer limits.
 */
function generateExtractionScript(outputPath: string): string {
  return `
/**
 * Convex Schema Extraction Script
 * Generated by ArchCodex - extracts schema using Convex's introspection API
 */

import { writeFileSync } from 'fs';

// Import the schema - path is relative to convex/ directory
import schemaModule from './schema.js';

// Output file path (injected by ArchCodex)
const OUTPUT_PATH = ${JSON.stringify(outputPath)};

// Handle ES module default export (schema might be at schemaModule.default or schemaModule directly)
const schema = schemaModule.default || schemaModule;

/**
 * Extract field information from a validator.
 */
function extractFieldInfo(name, validator, depth = 0) {
  if (depth > 10) return { name, kind: 'unknown', type: 'unknown' }; // Prevent infinite recursion

  const field = {
    name,
    kind: validator.kind,
    optional: false,
    isReference: false,
  };

  switch (validator.kind) {
    case 'string':
      field.type = 'string';
      break;
    case 'number':
    case 'float64':
    case 'int64':
      field.type = 'number';
      break;
    case 'boolean':
      field.type = 'boolean';
      break;
    case 'null':
      field.type = 'null';
      break;
    case 'any':
      field.type = 'any';
      break;
    case 'bytes':
      field.type = 'bytes';
      break;
    case 'id':
      field.type = 'Id<' + validator.tableName + '>';
      field.isReference = true;
      field.referenceTarget = validator.tableName;
      break;
    case 'array':
      const elementInfo = extractFieldInfo('element', validator.element, depth + 1);
      field.type = elementInfo.type + '[]';
      if (elementInfo.isReference) {
        field.isReference = true;
        field.referenceTarget = elementInfo.referenceTarget;
        field.isArrayReference = true;
      }
      break;
    case 'object':
      field.type = 'object';
      if (validator.fields) {
        field.nestedFields = Object.entries(validator.fields).map(
          ([n, v]) => extractFieldInfo(n, v, depth + 1)
        );
      }
      break;
    case 'union':
      field.type = 'union';
      if (validator.members) {
        field.unionMembers = validator.members.map(
          (m, i) => extractFieldInfo('member' + i, m, depth + 1)
        );
      }
      break;
    case 'literal':
      field.type = JSON.stringify(validator.value);
      break;
    case 'optional':
      const innerInfo = extractFieldInfo(name, validator.inner, depth + 1);
      return { ...innerInfo, optional: true };
    case 'record':
      field.type = 'record';
      break;
    default:
      field.type = validator.kind || 'unknown';
  }

  return field;
}

/**
 * Extract table information.
 */
function extractTable(tableName, tableInfo) {
  const fields = [];
  const relationships = [];

  // Add implicit Convex fields
  fields.push({
    name: '_id',
    type: 'Id<' + tableName + '>',
    optional: false,
    isReference: false,
  });
  fields.push({
    name: '_creationTime',
    type: 'number',
    optional: false,
    isReference: false,
  });

  // Extract fields from validator
  if (tableInfo.validator && tableInfo.validator.fields) {
    for (const [fieldName, validator] of Object.entries(tableInfo.validator.fields)) {
      const fieldInfo = extractFieldInfo(fieldName, validator);
      fields.push(fieldInfo);

      // Track relationships
      if (fieldInfo.isReference && fieldInfo.referenceTarget) {
        relationships.push({
          name: fieldName,
          type: fieldInfo.isArrayReference ? 'many_to_many' : 'belongs_to',
          target: fieldInfo.referenceTarget,
          field: fieldName,
        });
      }
    }
  }

  // Extract indexes (useful context)
  const indexes = [];
  if (tableInfo.indexes) {
    for (const [indexName, indexInfo] of Object.entries(tableInfo.indexes)) {
      indexes.push({
        name: indexName,
        fields: indexInfo.fields || [],
      });
    }
  }

  return {
    name: tableName,
    fields,
    relationships,
    indexes,
  };
}

// Main extraction
try {
  const tables = {};

  if (schema && schema.tables) {
    for (const [tableName, tableInfo] of Object.entries(schema.tables)) {
      tables[tableName] = extractTable(tableName, tableInfo);
    }
  }

  // Write JSON to file for inter-process communication (avoids stdout buffer limits)
  writeFileSync(OUTPUT_PATH, JSON.stringify({
    success: true,
    tables: Object.values(tables),
    tableCount: Object.keys(tables).length,
  }, null, 2), 'utf-8');
  process.exit(0);
} catch (error) {
  const message = error instanceof Error ? error.message : String(error);
  const stack = error instanceof Error ? error.stack : undefined;
  writeFileSync(OUTPUT_PATH, JSON.stringify({
    success: false,
    error: message,
    stack: stack,
  }, null, 2), 'utf-8');
  process.exit(1);
}
`;
}

/**
 * Result from the extraction script.
 */
interface ExtractionScriptResult {
  success: boolean;
  tables?: Array<{
    name: string;
    fields: Array<{
      name: string;
      type: string;
      optional: boolean;
      isReference: boolean;
      referenceTarget?: string;
      isArrayReference?: boolean;
    }>;
    relationships: Array<{
      name: string;
      type: string;
      target: string;
      field: string;
    }>;
    indexes?: Array<{
      name: string;
      fields: string[];
    }>;
  }>;
  tableCount?: number;
  error?: string;
}

/**
 * Execute the extraction script in the user's project.
 * Uses file-based IPC to avoid stdout buffer limits in Node.js child_process.
 */
async function executeExtractionScript(projectRoot: string): Promise<ExtractionScriptResult> {
  const scriptPath = path.join(projectRoot, 'convex', '_archcodex_extract.mjs');
  const outputPath = path.join(projectRoot, 'convex', '_archcodex_output.json');

  try {
    // Generate and write the extraction script with output path
    const script = generateExtractionScript(outputPath);
    await fsWriteFile(scriptPath, script, 'utf-8');

    // Execute with npx tsx
    execSync(`npx tsx "${scriptPath}"`, {
      cwd: projectRoot,
      timeout: 30000,
      env: { ...process.env, NODE_NO_WARNINGS: '1' },
    });

    // Read the JSON output from file
    const output = await readFile(outputPath, 'utf-8');
    return JSON.parse(output) as ExtractionScriptResult;
  } finally {
    // Clean up both files
    await Promise.all([
      unlink(scriptPath).catch(() => { /* Ignore cleanup errors */ }),
      unlink(outputPath).catch(() => { /* Ignore cleanup errors */ }),
    ]);
  }
}

/**
 * Convert script result to ExtractedEntity format.
 */
function convertToEntities(result: ExtractionScriptResult): ExtractedEntity[] {
  if (!result.success || !result.tables) {
    return [];
  }

  return result.tables.map(table => ({
    name: table.name,
    fields: table.fields.map(f => ({
      name: f.name,
      type: f.type,
      optional: f.optional,
      isReference: f.isReference,
      referenceTarget: f.referenceTarget,
    })),
    relationships: table.relationships.map(r => ({
      name: r.name,
      type: r.type as RelationshipType,
      target: r.target,
      field: r.field,
    })),
  }));
}

/**
 * Infer has_many relationships from belongs_to.
 */
function inferHasManyRelationships(entities: ExtractedEntity[]): ExtractedEntity[] {
  const entityMap = new Map(entities.map(e => [e.name, e]));

  for (const entity of entities) {
    for (const rel of entity.relationships) {
      if (rel.type === 'belongs_to') {
        const targetEntity = entityMap.get(rel.target);
        if (targetEntity) {
          const hasInverse = targetEntity.relationships.some(
            r => r.target === entity.name && r.type === 'has_many'
          );
          if (!hasInverse) {
            targetEntity.relationships.push({
              name: entity.name, // Use entity name directly (Convex tables are already pluralized)
              type: 'has_many',
              target: entity.name,
            });
          }
        }
      }
    }
  }

  return entities;
}

/**
 * Convex schema extractor using runtime introspection.
 */
export class ConvexSchemaExtractor implements ISchemaExtractor {
  readonly source = 'convex' as const;

  async canExtract(projectRoot: string): Promise<boolean> {
    for (const schemaPath of CONVEX_SCHEMA_PATHS) {
      const fullPath = path.join(projectRoot, schemaPath);
      if (await fileExists(fullPath)) {
        return true;
      }
    }
    return false;
  }

  async extract(options: ExtractionOptions): Promise<SchemaExtractionResult> {
    const { projectRoot, focusEntity } = options;

    // Find schema file path for the result
    let schemaPath: string | null = null;
    for (const relativePath of CONVEX_SCHEMA_PATHS) {
      const fullPath = path.join(projectRoot, relativePath);
      if (await fileExists(fullPath)) {
        schemaPath = fullPath;
        break;
      }
    }

    if (!schemaPath) {
      throw new Error('Convex schema not found');
    }

    // Execute extraction script
    const result = await executeExtractionScript(projectRoot);

    if (!result.success) {
      throw new Error(`Schema extraction failed: ${result.error}`);
    }

    // Convert to our format
    let entities = convertToEntities(result);

    // Infer has_many relationships
    entities = inferHasManyRelationships(entities);

    // Filter to focus entity if specified
    if (focusEntity) {
      const normalized = focusEntity.toLowerCase();
      entities = entities.filter(e =>
        e.name.toLowerCase() === normalized ||
        e.name.toLowerCase() === normalized + 's' ||
        e.name.toLowerCase().includes(normalized)
      );
    }

    return {
      source: 'convex',
      schemaPath,
      entities,
    };
  }
}

/**
 * Create a Convex schema extractor instance.
 */
export function createConvexExtractor(): ISchemaExtractor {
  return new ConvexSchemaExtractor();
}
