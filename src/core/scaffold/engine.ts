/**
 * @arch archcodex.core.engine
 * @intent:stateless
 * @intent:ast-analysis
 */
import * as path from 'node:path';
import { readFile, writeFile, fileExists, ensureDir } from '../../utils/file-system.js';
import type { Index, IndexEntry } from '../discovery/index.js';
import { findByArchId } from '../discovery/index.js';
import type { Registry } from '../registry/schema.js';
import { resolveArchitecture } from '../registry/resolver.js';
import type { FlattenedArchitecture } from '../registry/types.js';
import type {
  TemplateVariables,
  ScaffoldOptions,
  ScaffoldResult,
} from './types.js';
import { Project } from 'ts-morph';

/**
 * Default template for TypeScript files.
 */
const DEFAULT_TEMPLATE = `/**
 * @arch {{ARCH_ID}}
 *
 * {{CLASS_NAME}} - Generated by ArchCodex
 * Created: {{DATE}}
 */

export class {{CLASS_NAME}} {
  constructor() {
    // TODO: Implement constructor
  }
}
`;

/**
 * Template with reference implementation skeleton.
 */
const TEMPLATE_WITH_REFERENCE = `/**
 * @arch {{ARCH_ID}}
 *
 * {{CLASS_NAME}} - Generated by ArchCodex
 * Created: {{DATE}}
 *
 * Reference: {{REFERENCE_FILE}}
 */

{{REFERENCE_SKELETON}}
`;

/**
 * Scaffold engine for generating files from templates.
 */
export class ScaffoldEngine {
  private projectRoot: string;
  private templateDir: string;
  private registry?: Registry;

  constructor(projectRoot: string, templateDir: string = '.arch/templates', registry?: Registry) {
    this.projectRoot = projectRoot;
    this.templateDir = templateDir;
    this.registry = registry;
  }

  /**
   * Generate a file from a template.
   */
  async scaffold(options: ScaffoldOptions, index?: Index): Promise<ScaffoldResult> {
    const { archId, name, outputPath, template, variables = {}, overwrite = false } = options;

    // Get index entry if available
    const indexEntry = index ? findByArchId(index, archId) : undefined;

    // Get architecture from registry for file_pattern and default_path
    const architecture = this.getArchitecture(archId);

    // Extract reference skeleton if reference_implementations available
    const refFiles = architecture?.reference_implementations || [];
    const refSkeleton = await this.extractSkeleton(refFiles, name);

    // Build template variables (including reference info)
    const vars = this.buildVariables(archId, name, outputPath, indexEntry, architecture, {
      ...variables,
      ...(refSkeleton && {
        REFERENCE_FILE: refSkeleton.file,
        REFERENCE_SKELETON: refSkeleton.skeleton,
      }),
    });

    // Get template content (use reference template if skeleton available and no custom template)
    let templateContent: string;
    try {
      if (refSkeleton && !template && !indexEntry?.template) {
        // Use template with reference skeleton
        templateContent = TEMPLATE_WITH_REFERENCE;
      } else {
        templateContent = await this.getTemplateContent(
          template || indexEntry?.template
        );
      }
    } catch (error) {
      return {
        success: false,
        error: `Failed to load template: ${error instanceof Error ? error.message : 'Unknown error'}`,
      };
    }

    // Apply template substitution
    const content = this.applyTemplate(templateContent, vars);

    // Determine output path
    const finalPath = this.resolvePath(vars, outputPath, indexEntry, architecture);

    // Check if file exists
    if (!overwrite && (await fileExists(finalPath))) {
      return {
        success: false,
        error: `File already exists: ${finalPath}. Use --overwrite to replace.`,
      };
    }

    // Write file
    try {
      await ensureDir(path.dirname(finalPath));
      await writeFile(finalPath, content);

      return {
        success: true,
        filePath: finalPath,
        content,
      };
    } catch (error) {
      return {
        success: false,
        error: `Failed to write file: ${error instanceof Error ? error.message : 'Unknown error'}`,
      };
    }
  }

  /**
   * Build template variables.
   */
  private buildVariables(
    archId: string,
    name: string,
    outputPath: string | undefined,
    indexEntry: IndexEntry | undefined,
    architecture: FlattenedArchitecture | undefined,
    custom: Record<string, string>
  ): TemplateVariables {
    const now = new Date();
    const fileName = name.replace(/\.ts$/, '');

    // Extract layer from archId (e.g., "archcodex.core.engine" â†’ "core")
    const parts = archId.split('.');
    const layer = parts.length > 1 ? parts[1] : parts[0];

    return {
      ARCH_ID: archId,
      CLASS_NAME: name,
      FILE_NAME: fileName,
      FILE_PATH: outputPath || architecture?.default_path || indexEntry?.suggested_path || 'src',
      LAYER: layer,
      DATE: now.toISOString().split('T')[0],
      TIMESTAMP: now.toISOString(),
      ...custom,
    };
  }

  /**
   * Get flattened architecture from registry.
   */
  private getArchitecture(archId: string): FlattenedArchitecture | undefined {
    if (!this.registry) return undefined;

    try {
      const { architecture } = resolveArchitecture(this.registry, archId);
      return architecture;
    } catch {
      return undefined;
    }
  }

  /**
   * Get template content.
   */
  private async getTemplateContent(templateName?: string): Promise<string> {
    if (!templateName) {
      return DEFAULT_TEMPLATE;
    }

    const templatePath = path.resolve(
      this.projectRoot,
      this.templateDir,
      templateName
    );

    if (await fileExists(templatePath)) {
      return readFile(templatePath);
    }

    // Try with .hbs extension
    const templatePathWithExt = `${templatePath}.hbs`;
    if (await fileExists(templatePathWithExt)) {
      return readFile(templatePathWithExt);
    }

    throw new Error(`Template not found: ${templateName}`);
  }

  /**
   * Apply Handlebars-style substitution to template.
   */
  private applyTemplate(template: string, vars: TemplateVariables): string {
    let result = template;

    for (const [key, value] of Object.entries(vars)) {
      const pattern = new RegExp(`\\{\\{\\s*${key}\\s*\\}\\}`, 'g');
      result = result.replace(pattern, value);
    }

    return result;
  }

  /**
   * Resolve the final output path.
   * Priority: CLI option > architecture fields > index entry > defaults
   */
  private resolvePath(
    vars: TemplateVariables,
    outputPath: string | undefined,
    indexEntry: IndexEntry | undefined,
    architecture: FlattenedArchitecture | undefined
  ): string {
    let basePath: string;

    if (outputPath) {
      // CLI option takes precedence
      basePath = outputPath;
    } else if (architecture?.default_path) {
      // Architecture-defined default path (supports ${layer}, ${name} placeholders)
      basePath = this.interpolatePath(architecture.default_path, vars);
    } else if (indexEntry?.suggested_path) {
      basePath = this.applyTemplate(indexEntry.suggested_path, vars);
    } else {
      basePath = 'src';
    }

    let fileName: string;
    if (architecture?.file_pattern) {
      // Architecture-defined file naming pattern (e.g., "${name}Service.ts")
      fileName = this.interpolatePath(architecture.file_pattern, vars);
    } else if (indexEntry?.suggested_name) {
      fileName = this.applyTemplate(indexEntry.suggested_name, vars);
    } else {
      fileName = `${vars.CLASS_NAME}.ts`;
    }

    // Ensure .ts extension
    if (!fileName.endsWith('.ts')) {
      fileName += '.ts';
    }

    return path.resolve(this.projectRoot, basePath, fileName);
  }

  /**
   * Interpolate path placeholders like ${name}, ${layer}.
   */
  private interpolatePath(template: string, vars: TemplateVariables): string {
    return template
      .replace(/\$\{name\}/g, vars.CLASS_NAME)
      .replace(/\$\{layer\}/g, vars.LAYER || '')
      .replace(/\$\{arch_id\}/g, vars.ARCH_ID)
      .replace(/\$\{file_name\}/g, vars.FILE_NAME);
  }

  /**
   * Extract a skeleton from reference implementation files.
   * Returns imports + class/function signatures without bodies.
   */
  private async extractSkeleton(referenceFiles: string[], targetClassName?: string): Promise<{ file: string; skeleton: string } | undefined> {
    if (referenceFiles.length === 0) return undefined;

    // Try to load and parse the first reference file
    const refPath = path.resolve(this.projectRoot, referenceFiles[0]);
    if (!(await fileExists(refPath))) return undefined;

    try {
      const content = await readFile(refPath);
      const project = new Project({
        skipAddingFilesFromTsConfig: true,
        skipFileDependencyResolution: true,
      });
      const sourceFile = project.createSourceFile('temp.ts', content, { overwrite: true });

      const lines: string[] = [];

      // Add imports
      for (const importDecl of sourceFile.getImportDeclarations()) {
        const moduleSpec = importDecl.getModuleSpecifierValue();
        const namedImports = importDecl.getNamedImports();
        const defaultImport = importDecl.getDefaultImport();
        const isTypeOnly = importDecl.isTypeOnly();

        if (isTypeOnly && namedImports.length > 0) {
          lines.push(`import type { ${namedImports.map(n => n.getName()).join(', ')} } from '${moduleSpec}';`);
        } else if (namedImports.length > 0) {
          lines.push(`import { ${namedImports.map(n => n.getName()).join(', ')} } from '${moduleSpec}';`);
        } else if (defaultImport) {
          lines.push(`import ${defaultImport.getText()} from '${moduleSpec}';`);
        }
      }

      if (lines.length > 0) lines.push('');

      // Add class signatures (use target class name if provided)
      const classes = sourceFile.getClasses();
      for (let i = 0; i < classes.length; i++) {
        const classDecl = classes[i];
        // Use targetClassName for the first/main class, otherwise use original name
        const originalName = classDecl.getName() || 'Anonymous';
        const className = (i === 0 && targetClassName) ? targetClassName : originalName;
        const isExported = classDecl.isExported();
        const extendsClause = classDecl.getExtends()?.getText();
        const implementsClause = classDecl.getImplements().map(impl => impl.getText());

        const exportPrefix = isExported ? 'export ' : '';
        const extendsStr = extendsClause ? ` extends ${extendsClause}` : '';
        const implementsStr = implementsClause.length > 0 ? ` implements ${implementsClause.join(', ')}` : '';

        lines.push(`${exportPrefix}class ${className}${extendsStr}${implementsStr} {`);

        // Add method signatures
        for (const method of classDecl.getMethods()) {
          const methodName = method.getName();
          const isStatic = method.isStatic();
          const isAsync = method.isAsync();
          const scope = method.getScope() || 'public';

          const staticMod = isStatic ? 'static ' : '';
          const asyncMod = isAsync ? 'async ' : '';
          lines.push(`  ${scope} ${staticMod}${asyncMod}${methodName}(): void {`);
          lines.push('    // TODO: Implement');
          lines.push('  }');
          lines.push('');
        }

        lines.push('}');
      }

      // Add function signatures
      for (const funcDecl of sourceFile.getFunctions()) {
        const funcName = funcDecl.getName() || 'anonymous';
        const isExported = funcDecl.isExported();
        const isAsync = funcDecl.isAsync();

        const exportPrefix = isExported ? 'export ' : '';
        const asyncMod = isAsync ? 'async ' : '';
        lines.push(`${exportPrefix}${asyncMod}function ${funcName}(): void {`);
        lines.push('  // TODO: Implement');
        lines.push('}');
        lines.push('');
      }

      return {
        file: referenceFiles[0],
        skeleton: lines.join('\n'),
      };
    } catch {
      return undefined;
    }
  }
}
