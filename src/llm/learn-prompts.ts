/**
 * @arch archcodex.core.domain.llm
 *
 * Shared prompt building and response parsing for architecture learning.
 */
import type { LLMLearnRequest, LLMLearnResponse } from './types.js';

/**
 * Build the learn prompt for LLM analysis.
 */
export function buildLearnPrompt(request: LLMLearnRequest): string {
  const lines = [
    'TASK: Generate an ArchCodex registry.yaml from a project skeleton.',
    '',
    'CONTEXT: ArchCodex enforces architectural constraints on codebases. The registry defines:',
    '- Architectures: Named patterns that files can declare with @arch tags',
    '- Constraints: Rules like forbid_import, max_file_lines, require_test_file',
    '- Inheritance: Architectures can inherit from others (inherits: base)',
    '',
    'PROJECT SKELETON:',
    request.skeletonYaml,
    '',
  ];

  if (request.userHints) {
    lines.push(`USER REQUIREMENTS: ${request.userHints}`);
    lines.push('');
  }

  if (request.existingRegistry) {
    lines.push('EXISTING REGISTRY (extend or improve this):');
    lines.push(request.existingRegistry);
    lines.push('');
  }

  lines.push('INSTRUCTIONS:');
  lines.push('1. Create "base" architecture with project-wide constraints');
  lines.push('2. Create layer architectures (e.g., domain, infra, cli) inheriting from base');
  lines.push('3. Add forbid_import constraints to enforce layer boundaries');
  lines.push('4. Add rationale explaining WHEN to use each architecture');
  lines.push('5. Use descriptive IDs: project.layer.component (e.g., myapp.domain.service)');
  lines.push('');
  lines.push('CONSTRAINT RULES AVAILABLE:');
  lines.push('- forbid_import: [module1, module2] - Prevent importing these');
  lines.push('- require_import: [module] - Must import these');
  lines.push('- max_file_lines: 400 - Limit file size');
  lines.push('- require_test_file: ["*.test.ts"] - Require companion test');
  lines.push('- naming_pattern: "^[A-Z].*Service\\.ts$" - Enforce naming');
  lines.push('');
  lines.push('OUTPUT FORMAT (valid YAML only, no markdown, no explanations):');
  lines.push('');
  lines.push('base:');
  lines.push('  description: Root architecture for all code');
  lines.push('  rationale: |');
  lines.push('    Use for: Files that don\'t fit specific patterns.');
  lines.push('    Don\'t use for: Domain logic, infrastructure code.');
  lines.push('  constraints:');
  lines.push('    - rule: max_file_lines');
  lines.push('      value: 400');
  lines.push('      severity: warning');
  lines.push('      why: Keep files focused and maintainable');
  lines.push('');
  lines.push('project.domain:');
  lines.push('  inherits: base');
  lines.push('  description: Domain/business logic');
  lines.push('  rationale: |');
  lines.push('    Use for: Business rules, entities, services.');
  lines.push('  constraints:');
  lines.push('    - rule: forbid_import');
  lines.push('      value: [express, fastify]');
  lines.push('      severity: error');
  lines.push('      why: Domain must not depend on infrastructure');

  return lines.join('\n');
}

/**
 * Parse learn response from LLM.
 */
export function parseLearnResponse(
  content: string,
  providerName: string
): Omit<LLMLearnResponse, 'tokenUsage'> {
  // Extract YAML from response
  let yaml = content;

  // Strip markdown code blocks if present
  const codeBlockMatch = content.match(/```(?:yaml)?\s*([\s\S]*?)```/);
  if (codeBlockMatch) {
    yaml = codeBlockMatch[1];
  }

  // Remove any non-YAML preamble
  const yamlStart = yaml.search(/^[a-zA-Z_][a-zA-Z0-9_]*:/m);
  if (yamlStart > 0) {
    yaml = yaml.substring(yamlStart);
  }

  return {
    registryYaml: yaml.trim(),
    explanation: `Generated by ${providerName} based on project skeleton analysis.`,
    suggestions: [
      'Review and adjust the generated architectures',
      'Run: archcodex simulate <generated-registry> to preview impact',
      'Run: archcodex migrate-registry <generated-registry> to convert to multi-file format',
      'Update @arch tags in files to use the new architectures',
    ],
    confidence: 0.7,
  };
}

/**
 * Build learn instructions for prompt provider.
 */
export function buildLearnInstructions(request: LLMLearnRequest): string {
  const lines = [
    'Analyze the project skeleton and generate a registry.yaml file.',
    '',
    'The registry should:',
    '- Define base architecture with common constraints',
    '- Create layer-specific architectures (cli, core, infra, util)',
    '- Add constraints based on observed import patterns',
    '- Include descriptions and rationale for each architecture',
    '',
    'Output valid YAML only. No explanations or markdown.',
  ];

  if (request.userHints) {
    lines.push('');
    lines.push(`User hints: ${request.userHints}`);
  }

  return lines.join('\n');
}

/**
 * Format the learn prompt for human-readable output (prompt provider).
 */
export function formatLearnPromptForDisplay(request: LLMLearnRequest): string {
  const lines: string[] = [
    '═'.repeat(70),
    'ARCHCODEX LEARN REQUEST',
    '═'.repeat(70),
    '',
    'Analyze this project skeleton and generate a registry.yaml file.',
    '',
    '─'.repeat(70),
    'PROJECT SKELETON:',
    '─'.repeat(70),
    '',
    request.skeletonYaml,
    '',
  ];

  if (request.userHints) {
    lines.push('─'.repeat(70));
    lines.push('USER HINTS:');
    lines.push('─'.repeat(70));
    lines.push('');
    lines.push(request.userHints);
    lines.push('');
  }

  if (request.existingRegistry) {
    lines.push('─'.repeat(70));
    lines.push('EXISTING REGISTRY (for reference):');
    lines.push('─'.repeat(70));
    lines.push('');
    lines.push(request.existingRegistry);
    lines.push('');
  }

  lines.push('─'.repeat(70));
  lines.push('INSTRUCTIONS:');
  lines.push('─'.repeat(70));
  lines.push('');
  lines.push('Generate a registry.yaml file that:');
  lines.push('');
  lines.push('1. Identifies natural domain boundaries (layers, modules, features)');
  lines.push('2. Creates a hierarchy: base → layer → specific');
  lines.push('3. Adds constraints that enforce observed boundaries:');
  lines.push('   - forbid_import: Prevent layer violations');
  lines.push('   - max_file_lines: Keep files focused');
  lines.push('   - require_test_file: For core business logic');
  lines.push('4. Adds meaningful descriptions and rationale');
  lines.push('5. Suggests mixins for cross-cutting concerns (tested, srp, dip)');
  lines.push('');
  lines.push('OUTPUT FORMAT:');
  lines.push('Valid YAML following the ArchCodex registry schema.');
  lines.push('Include a "base" architecture that others inherit from.');
  lines.push('');
  lines.push('═'.repeat(70));

  return lines.join('\n');
}
